# 클린 아키텍처

서문의 내용 중 가장 마음에 와닿는 말 : 훌륭한 소프트웨어 아키텍처가 시스템, 프로젝트, 팀에 놀라운 효과를 가져오는 것을 확인했다. 나는 천국을 가 보았다.

# 설계와 아키텍처

설계와 아키텍처는 같은 것이다. 개별로는 존재할 수 없고, 실제로 이 둘을 구분 짓기는 어렵다. 고수준에서 저수준으로 향하는 의사결정의 연속성이다

좋은 소프트웨어 설계의 목표는 필요한 시스템을 만들고 유지보수하는 데 투입되는 인력을 최소화하는 데 있다.

빨리 가는 유일한 방법은 제대로 가는 것이다.

어떤 경우라도 개발 조직이 할 수 있는 최고의 선택지는 조직에 스며든 과신을 인지하여 방지하고, 소프트웨어 아키텍처의 품질을 심각하게 고민하기 시작하는 것이다. 그럴려면 좋은 아키텍처가 무엇인지 이해해야 한다.

프로그래머를 고용하는 이유는 이해관계자를 위해 기계가 수익을 창출하거나 비용을 절약하도록 만들기 위해서다

소프트웨어=부드러운+제품,상품. 소프트웨어는 ‘부드러움을 지니도록’ 만들어졌다. 소프트웨어를 만든 이유는 기계의 행위를 쉽게 변경할 수 있도록 하기 위해서다.

아키텍처가 후순위가 되면 시스템을 개발하는 비용이 더 많이 들고, 일부 또는 전체 시스템에 변경을 가하는 일이 현실적으로 불가능해진다.

# 패러다임

세가지의 패러다임은 모두 아키텍처와 관계가 있다. 우리는 아키텍처 경계를 넘나들기 위한 메커니즘으로 다형성을 이용한다. 함수형 프로그래밍을 이요와여 데이터의 위치와 접근 방법에 대해 규칙을 부과한다. 모듈의 기반 알고리즘으로 구조적 프로그래밍을 사용한다.

아키텍처의 세 가지 큰 관심사=함수, 컴포넌트 관리, 데이터 관리

데이크스트라는 “테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수는 없다”고 얘기했다. 다시말해 프로그램이 잘못되었음을 테스트를 통해 증명할 수는 있지만, 프로그램이 맞다고 증명할 수는 없다.

# 경계 선긋기가 필요한 이유
 저자는 아들과 함께 FitNesse라는 위키페이지를 만들었는데, 초기에 데이터베이스에 대해 고민하지 말자고 결정을 내렸다. 대신 어떤 데이터베이스를 사용하더라도 상관없는 형태로 설계함으로써 의도적으로 데이터베이스에 대한 결정을 미루었다. 데이터를 가져오고 저장하는 일과는 관련 없는 기능을 구현하는 동안에는 이들 메서드를 단순히 스텁으로 만들었다. MockWikiPage라는 이름의 클래스를 만들고, 그 안의 데이터 접근 메서드들은 단순히 스텁으로 남겨주었다. 마침내 작성하려고 하는 기능에서 데이터 접근이 필요하게 되었는데, 데이터베이스를 사용하지 않고 RAM에 저장하도록 만들었다.<br>
 이 덕분에 일 년 내내 기능을 차례대로 작성할 수 있었다. 역속성을 구현해야 하는 시점이 되자 단기적으로는 데이터베이스가 필요없다고 다시 또 결정을 내렸다. 플랫 파일에 저장하도록 결정을 내려 FileSystemWikiPage를 구현하였다. 그런 후 또 다른 기능들을 계속해서 개발했다. 석 달이 지난 후 플랫 파일을 사용한 해결책이 적합했다는 결론에 도달했고, MySQL에 관련된 아이디어는 완전히 폐기하였다. 고객 요구사항으로 MySQL을 사용하는 클래스를 만들었지만, 이를 요구한 고객 조차 이를 사용하지 않았다.<br>
 FItNesse 개발 초기에 업무 규칙과 데이터베이스 사이에 경계선을 그었다. 이 경계선을 통해 업무 규칙은 데이터 접근 메서드 외에는 데이터베이스에 관해서 어떤 것도 알지 못하게 되었다. 이러한 결정으로 일 년이 훨씬 넘는 기간 동안 데이터베이스를 선택하고 구현하는 일을 연기할 수 있었다. 이 결정으로 파일 시스템을 선택하여 시도해볼 수도 있었고, 더 나은 해결책이 보이면 방향을 바꿀 수도 있었다.<br>
 운영할 데이터베이스가 없다는 사실은 스키마와 관련된 문제들, 쿼리 문제들, 데이터베이스 서버 문제들, 패스워드 문제들, 접속 시간과 관련된 문제들, 그리고 데이터베이스를 작동시킬 때 추하게 고개를 드는 여타 모든 고약한 문제가 없었다는 사실을 뜻한다. 또한 테스트를 트리게 만드는 데이터베이스가 없으니 테스트를 더 빨리 돌릴 수 있다는 뜻이기도 하다.<br>
 경계선을 긋는 행위는 결정을 늦추고 연기하는 데 도움이 되었고, 궁극적으로는 시간을 엄청나게 절약해주었으며, 골치를 썩지 않게 해주었다. 이것이 좋은 아키텍처라면 반드시 해야 하는 일이다.

# 경계 : 선긋기
관련이 있는 것과 없는 것 사이에 선을 긋는다.

데이터베이스는 오라클, MySQL, 카우치, Atomic 등으로 구현할 수 있고, 심지어 플랫 파일로도 구현할 수 있다. 업무 규칙은 전혀 개의치 않는다. 그리고 이 같은 사실은 데이터베이스에 대한 결정은 연기할 수 있으며, 데이터베이스를 결정하기에 앞서 업무 규칙을 먼저 작성하고 테스트하는 데 집중할 수 있음을 의미한다.

# 아키텍처
여러분의 애플리케이션 아키텍처는 뭐라고 소리치는가? 상위 수준의 디렉터리 구조, 최상위 패키지에 담긴 소스 파일을 볼 때, 이 아키텍처는 "헬스 케어 시스템이야" 또는 "재고 관리 시스템이야"라고 소리치는가? 아니면 "레일즈야", "스프링/하이버네이트야", 아니면 "ASP야"라고 소리치는가?
<<Object Oriented Software Engineering>> 저서를 쓴 이바 야콥슨은 소프트웨어 아키텍처는 시스템의 유스케이스를 지원하는 구조라고 지적했다. 주택이나 도서관의 계획서가 해당 건축물의 유스케이스에 대해 소리치는 것 처럼, 소프트웨어 애플리케이션의 아키텍처도 애플리케이션의 유스케이스에 대해 소리쳐야 한다.
아키텍처를 프레임워크로부터 제공받아서는 절대 안 된다. 프레임워크는 사용하는 도구일 뿐, 아키텍처가 준수해야 할 대상이 아니다.

# 아키텍처의 목적
아키텍트가 주목하는 첫 번째 관심사는 주택이 거주하기에 적합한 공간임을 확실히 하는 것이지, 벽돌로 지어지는지를 확인하는 것이 아니다.

 좋은 소프트웨어 아키텍처는 프레임웤, 데이터베이스, 웹 서버, 그리고 여타 개발 환경 문제나 도구에 대해서는 결정을 미룰 수 있도록 만든다. 프레임워크는 열어 둬야 할 선택사항이다. 좋은 아키텍처는 프로젝트의 훨씬 후반까지 레일스, 스프링, 하이버네이트, 톰캣, MySQL에 대한 결정을 하지 않아도 되도록 해준다. 뿐만 아니라 이러한 결정을 쉽게 번복할 수 있도록 한다.

 # 웹
 웹은 아키텍처일까? 당연히 아니다! 웹은 전달 메커니즘(입출력 장치)이며, 애플리케이션 아키텍처에서도 그와 같이 다뤄야 한다.

 애플리케이션이 웹을 통해 전달된다는 사실은 세부사항이며, 시스템 구조를 지배해서는 절대 안 된다. 실제 애플리케이션을 웹으로 전달할지 여부는 미루어야 할 결정사항 중 하나다.

 시스템 아키텍처는 시스템이 어떻게 전달될지에 대해 가능하다면 아무것도 몰라야 한다. 과도한 문제를 일으키거나 근본적인 아키텍처를 뜯어고치지 않더라도 시스템을 콘솔 앱, 웹 앱, 리치 클라이언트 앱, 심지어 웹서비스 앱으로도 전달할 수 있어야 한다.

 # 클린 아키텍처
 시스템 아키텍처와 관련된 여러 가지 아이디어가 있다.
  - 육각형 아키텍처(Hexagonal Architecture)
  - DCI(Data, Context and Interaction)
  - BCE(Boundary-Control-Entity)
이들 아키텍처는 세부적인 면에서는 다소 차이가 있더라도 목표는 모두 같다. 바로 관심사의 분리(separation of concerns)다. 이들은 모두 소프트웨어를 계층으로 분리함으로써 관심사의 분리라는 목표를 달성할 수 있었다.

이들 아키텍처는 모두 시스템이 다음과 같은 특징을 지니도록 만든다.
 - 프레임워크 독립성
 - 테스트 용이성
 - UI 독립성
 - 데이터베이스 독립성
 - 모든 외부 에이전시에 대한 독립성
아래 다이어그램은 이들 아키텍처 전부를 실행 가능한 하나의 아이디어로 통합하려는 시도다.

![image](https://github.com/ChaYujin/TodayILearned/assets/19955465/a413e848-ca65-48cc-9f00-297b952cf1ae)

