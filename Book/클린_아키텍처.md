# 클린 아키텍처

서문의 내용 중 가장 마음에 와닿는 말 : 훌륭한 소프트웨어 아키텍처가 시스템, 프로젝트, 팀에 놀라운 효과를 가져오는 것을 확인했다. 나는 천국을 가 보았다.

# 설계와 아키텍처

설계와 아키텍처는 같은 것이다. 개별로는 존재할 수 없고, 실제로 이 둘을 구분 짓기는 어렵다. 고수준에서 저수준으로 향하는 의사결정의 연속성이다

좋은 소프트웨어 설계의 목표는 필요한 시스템을 만들고 유지보수하는 데 투입되는 인력을 최소화하는 데 있다.

빨리 가는 유일한 방법은 제대로 가는 것이다.

어떤 경우라도 개발 조직이 할 수 있는 최고의 선택지는 조직에 스며든 과신을 인지하여 방지하고, 소프트웨어 아키텍처의 품질을 심각하게 고민하기 시작하는 것이다. 그럴려면 좋은 아키텍처가 무엇인지 이해해야 한다.

프로그래머를 고용하는 이유는 이해관계자를 위해 기계가 수익을 창출하거나 비용을 절약하도록 만들기 위해서다

소프트웨어=부드러운+제품,상품. 소프트웨어는 ‘부드러움을 지니도록’ 만들어졌다. 소프트웨어를 만든 이유는 기계의 행위를 쉽게 변경할 수 있도록 하기 위해서다.

아키텍처가 후순위가 되면 시스템을 개발하는 비용이 더 많이 들고, 일부 또는 전체 시스템에 변경을 가하는 일이 현실적으로 불가능해진다.

# 패러다임

세가지의 패러다임은 모두 아키텍처와 관계가 있다. 우리는 아키텍처 경계를 넘나들기 위한 메커니즘으로 다형성을 이용한다. 함수형 프로그래밍을 이요와여 데이터의 위치와 접근 방법에 대해 규칙을 부과한다. 모듈의 기반 알고리즘으로 구조적 프로그래밍을 사용한다.

아키텍처의 세 가지 큰 관심사=함수, 컴포넌트 관리, 데이터 관리

데이크스트라는 “테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수는 없다”고 얘기했다. 다시말해 프로그램이 잘못되었음을 테스트를 통해 증명할 수는 있지만, 프로그램이 맞다고 증명할 수는 없다.

# 경계 선긋기가 필요한 이유
 저자는 아들과 함께 FitNesse라는 위키페이지를 만들었는데, 초기에 데이터베이스에 대해 고민하지 말자고 결정을 내렸다. 대신 어떤 데이터베이스를 사용하더라도 상관없는 형태로 설계함으로써 의도적으로 데이터베이스에 대한 결정을 미루었다. 데이터를 가져오고 저장하는 일과는 관련 없는 기능을 구현하는 동안에는 이들 메서드를 단순히 스텁으로 만들었다. MockWikiPage라는 이름의 클래스를 만들고, 그 안의 데이터 접근 메서드들은 단순히 스텁으로 남겨주었다. 마침내 작성하려고 하는 기능에서 데이터 접근이 필요하게 되었는데, 데이터베이스를 사용하지 않고 RAM에 저장하도록 만들었다.<br>
 이 덕분에 일 년 내내 기능을 차례대로 작성할 수 있었다. 역속성을 구현해야 하는 시점이 되자 단기적으로는 데이터베이스가 필요없다고 다시 또 결정을 내렸다. 플랫 파일에 저장하도록 결정을 내려 FileSystemWikiPage를 구현하였다. 그런 후 또 다른 기능들을 계속해서 개발했다. 석 달이 지난 후 플랫 파일을 사용한 해결책이 적합했다는 결론에 도달했고, MySQL에 관련된 아이디어는 완전히 폐기하였다. 고객 요구사항으로 MySQL을 사용하는 클래스를 만들었지만, 이를 요구한 고객 조차 이를 사용하지 않았다.<br>
 FItNesse 개발 초기에 업무 규칙과 데이터베이스 사이에 경계선을 그었다. 이 경계선을 통해 업무 규칙은 데이터 접근 메서드 외에는 데이터베이스에 관해서 어떤 것도 알지 못하게 되었다. 이러한 결정으로 일 년이 훨씬 넘는 기간 동안 데이터베이스를 선택하고 구현하는 일을 연기할 수 있었다. 이 결정으로 파일 시스템을 선택하여 시도해볼 수도 있었고, 더 나은 해결책이 보이면 방향을 바꿀 수도 있었다.<br>
 운영할 데이터베이스가 없다는 사실은 스키마와 관련된 문제들, 쿼리 문제들, 데이터베이스 서버 문제들, 패스워드 문제들, 접속 시간과 관련된 문제들, 그리고 데이터베이스를 작동시킬 때 추하게 고개를 드는 여타 모든 고약한 문제가 없었다는 사실을 뜻한다. 또한 테스트를 트리게 만드는 데이터베이스가 없으니 테스트를 더 빨리 돌릴 수 있다는 뜻이기도 하다.<br>
 경계선을 긋는 행위는 결정을 늦추고 연기하는 데 도움이 되었고, 궁극적으로는 시간을 엄청나게 절약해주었으며, 골치를 썩지 않게 해주었다. 이것이 좋은 아키텍처라면 반드시 해야 하는 일이다.

# 경계 : 선긋기
관련이 있는 것과 없는 것 사이에 선을 긋는다.

데이터베이스는 오라클, MySQL, 카우치, Atomic 등으로 구현할 수 있고, 심지어 플랫 파일로도 구현할 수 있다. 업무 규칙은 전혀 개의치 않는다. 그리고 이 같은 사실은 데이터베이스에 대한 결정은 연기할 수 있으며, 데이터베이스를 결정하기에 앞서 업무 규칙을 먼저 작성하고 테스트하는 데 집중할 수 있음을 의미한다.

# 아키텍처
여러분의 애플리케이션 아키텍처는 뭐라고 소리치는가? 상위 수준의 디렉터리 구조, 최상위 패키지에 담긴 소스 파일을 볼 때, 이 아키텍처는 "헬스 케어 시스템이야" 또는 "재고 관리 시스템이야"라고 소리치는가? 아니면 "레일즈야", "스프링/하이버네이트야", 아니면 "ASP야"라고 소리치는가?
<<Object Oriented Software Engineering>> 저서를 쓴 이바 야콥슨은 소프트웨어 아키텍처는 시스템의 유스케이스를 지원하는 구조라고 지적했다. 주택이나 도서관의 계획서가 해당 건축물의 유스케이스에 대해 소리치는 것 처럼, 소프트웨어 애플리케이션의 아키텍처도 애플리케이션의 유스케이스에 대해 소리쳐야 한다.
아키텍처를 프레임워크로부터 제공받아서는 절대 안 된다. 프레임워크는 사용하는 도구일 뿐, 아키텍처가 준수해야 할 대상이 아니다.

# 아키텍처의 목적
아키텍트가 주목하는 첫 번째 관심사는 주택이 거주하기에 적합한 공간임을 확실히 하는 것이지, 벽돌로 지어지는지를 확인하는 것이 아니다.

 좋은 소프트웨어 아키텍처는 프레임웤, 데이터베이스, 웹 서버, 그리고 여타 개발 환경 문제나 도구에 대해서는 결정을 미룰 수 있도록 만든다. 프레임워크는 열어 둬야 할 선택사항이다. 좋은 아키텍처는 프로젝트의 훨씬 후반까지 레일스, 스프링, 하이버네이트, 톰캣, MySQL에 대한 결정을 하지 않아도 되도록 해준다. 뿐만 아니라 이러한 결정을 쉽게 번복할 수 있도록 한다.

 # 웹
 웹은 아키텍처일까? 당연히 아니다! 웹은 전달 메커니즘(입출력 장치)이며, 애플리케이션 아키텍처에서도 그와 같이 다뤄야 한다.

 애플리케이션이 웹을 통해 전달된다는 사실은 세부사항이며, 시스템 구조를 지배해서는 절대 안 된다. 실제 애플리케이션을 웹으로 전달할지 여부는 미루어야 할 결정사항 중 하나다.

 시스템 아키텍처는 시스템이 어떻게 전달될지에 대해 가능하다면 아무것도 몰라야 한다. 과도한 문제를 일으키거나 근본적인 아키텍처를 뜯어고치지 않더라도 시스템을 콘솔 앱, 웹 앱, 리치 클라이언트 앱, 심지어 웹서비스 앱으로도 전달할 수 있어야 한다.

 # 클린 아키텍처
 시스템 아키텍처와 관련된 여러 가지 아이디어가 있다.
  - 육각형 아키텍처(Hexagonal Architecture)
  - DCI(Data, Context and Interaction)
  - BCE(Boundary-Control-Entity)
이들 아키텍처는 세부적인 면에서는 다소 차이가 있더라도 목표는 모두 같다. 바로 관심사의 분리(separation of concerns)다. 이들은 모두 소프트웨어를 계층으로 분리함으로써 관심사의 분리라는 목표를 달성할 수 있었다.

이들 아키텍처는 모두 시스템이 다음과 같은 특징을 지니도록 만든다.
 - 프레임워크 독립성
 - 테스트 용이성
 - UI 독립성
 - 데이터베이스 독립성
 - 모든 외부 에이전시에 대한 독립성

아래 다이어그램은 이들 아키텍처 전부를 실행 가능한 하나의 아이디어로 통합하려는 시도다.

![image](https://github.com/ChaYujin/TodayILearned/assets/19955465/a413e848-ca65-48cc-9f00-297b952cf1ae)

각각의 동심원은 소프트웨어에서 서로 다른 영역을 표현한다. 보통 안으로 들어갈수록 고수준의 소프트웨어가 된다. 바깥쪽 원은 메커니즘이고, 안쪽 원은 정책이다.

이러한 아키텍처가 동작하도록 하는 가장 중요한 규칙은 의존성 규칙이다.
```
소스 코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 한다.
```
내부의 원에 속한 요소는 외부의 원에 속한 어떤 것도 알지 못한다. 특히 내부의 원에 속한 코드는 외부의 원에 선언된 어떤 것에 대해서도 그 이름을 언급해서는 절대 안 된다. 우리는 외부 원에 위치한 어떤 것도 내부의 원에 영향을 주지 않기를 바란다.
 - 엔티티 : 전사적인 핵심 업무 규칙을 캡슐화한다. 엔티티는 메서드를 가지는 객체이거나 일련의 데이터 구조와 함수의 집합일 수도 있다.
 - 유스케이스 : 유스케이스 계층의 소프트웨어는 애플리케이션에 특화된 업무 규칙을 포함한다. 또한 유스케이스 계층의 소프트웨어는 시스템의 모든 유스케이스를 캡슐화하고 구현한다. 엔티티로 들어오고 나가는 데이터 흐름을 조정하며, 엔티티가 자신의 핵심 업무 규칙을 사용해서 유스케이스의 목적을 달성하도록 이끈다.
 - 인터페이스 어댑터 : 인터페이스 어댑터 계층은 이련의 어댑터들로 구성된다. 어댑터는 데이터를 유스케이스와 엔티티에게 가장 편리한 형식에서 데이터베이스나 웹 같은 외부 에이전시에게 가장 편리한 형식으로 변환단다. 이 계층은, 예를들어 GUI의 MVC 아키텍처를 모두 포괄한다. 모델은 그저 데이터 구조 정도에 지나지 않으며, 컨트롤러에서 유스케이스로 전달되고, 다시 유스케이스에서 프레젠터와 뷰로 되돌아 간다.
 - 프레임워크와 드라이버 : 가장 바깥쪽 계층은 일반적으로 데이터베이스나 웹 프레임워크 같은 프레임워크나 도구들로 구성된다. 일반적으로 이 계층에서는 안쪽원과 통신하기 위한 접한 코드 외에는 특별히 더 작성해야 할 코드가 그다지 많지 않다. 프레임워크와 드라이버 계층은 모든 세부사항이 위치하는 곳이다. 웹과 데이터베이스와 같은 세부사항들이다.

### 경계 횡단하기
 제어흐름과 의존성의 방향이 명백히 반대여야 하는 경우, 대체로 의존성 역전 원칙을 사용하여 해결한다. 

 예를 들어 유스케이스에서 프레젠터를 호출해야 한다고 가정해 보자. 이때 직접 호출해서는 안 되는데, 직접 호출해 버리면 의존성 규칙(내부의 원에서는 외부 원에 있는 어떤 이름도 언급해서는 안 된다)을 위배하기 때문이다. 따라서 우리는 유스케이스가 내부 원의 인터페이스를 호출하도록 하고, 외부 원의 프레젠터가 그 인터페이스를 구현하도록 만든다.

 아키텍처 경계를 횡단할 때 언제라도 동이한 기법을 사용할 수 있다. 우리는 동적 다형성을 이용하여 소스 코드 의존성을 제어흐름과는 반대로 만들 수 있고, 이를 통해 제어흐름이 어느 방향으로 흐르더라도 의존성 규칙을 준수할 수 있다.

 ### 경계를 횡단하는 데이터는 어떤 모습인가
 경계를 가로지르는 데이터는 흔히 간단한 데이터 구조로 이루어져 있다. 기본적인 구조체나 간단한 데이터 전송 객체(data transfer object,DTO) 등 원하는 대로 고를 수 있다. 또는 함수를 호출할 때 간단한 인자를 사용해서 데이터로 전달할 수도 있다. 그게 아니라면 데이터를 해시맵으로 묶거나 객체로 구성할 수도 있다. 중요한 점은 격리되어 있는 간단한 데이터 구조가 경계를 가로질러 전달된다는 사실이다. 꾀를 부려서 엔티티 객체나 데이터베이스의 행을 전달하는 일은 원치 않는다. 우리는 데이터 구조가 어떤 의존성을 가져 의존성 규칙을 위배하게 되는 일은 바라지 않는다.
 경계를 가로질러 데이터를 전달할 때, 데이터는 항상 내부의 원에서 사용하기에 가장 편리한 형태를 가져야만 한다.

 # 험블 객체 패턴
  험블 객체 패턴은 디자인 패턴으로, 테스트하기 어려운 행위와 테스트하기 쉬운 행위를 단위 테스트 작성자가 분리하기 쉽게 하는 방법으로 고안되었다. 행위들은 두 개의 모듈 또는 클래스로 나눈다. 이들 모듈 중 하나가 험블(humble)이다. 가장 기본적인 본질은 남기고, 테스트하기 어려운 행위를 모두 험블 객체로 옮긴다. 나머지 모듈에는 험블 객체에 속하지 않은, 테스트하기 쉬운 행위를 모두 옮긴다.

  테스트 용이성은 좋은 아키텍처가 지녀야 할 속성으로 오랫동안 알려져 왔다. 험블 객체 패턴이 좋은 예인데, 행위를 테스트하기 쉬운 부분과 테스트하기 어려운 부분으로 분리하면 아키텍처 경계가 정의되기 때문이다. 프레젠터와 뷰 사이의 경계는 이러한 경계 중 하나이며, 이 밖에도 수많은 경계가 존재한다.

  각 아키텍처 경계마다 경계 가까이 숨어있는 험블 객체 패턴을 발견할 수 있다. 경계를 넘나드는 통신은 거의 모두 간단한 데이터 구조를 수반할 때가 많고, 대개 그 경계는 테스트하기 어려운 무언가와 테스트하기 쉬운 무언가로 분리될 것이다. 그리고 이러한 아키텍처 경계에서 험블 객체 패턴을 사용하면 전체 시스템의 테스트 용이성을 크게 높일 수 있다.

# 계층과 경계
아키텍처 경계가 어디에나 존재한다. 아키텍트로서 우리는 아키텍처 경계가 언제 필요한지를 신중하게 파악해내야 한다. 또한 우리는 이러한 경계를 제대로 구현하려면 비용이 많이 든다는 사실도 인지하고 있어야 한다. 이와 동시에 이러한 경계가 무시되었다면 나중에 추가하는 비용이 크다는 사실도 알아야 한다.

그러면 아키텍트인 우리는 어떻게 해야 할까? 매우 똑똑한 일부 사람들이 우리에게 수년 동안 말해왔듯이, 추상화가 필요하리라고 미리 예측해서는 안 된다. 이것이 YAGNI(You Aren't Going to Need It) 가 말하는 철학이다. 이 문구에는 지혜가 담겨 있는데, 오버 엔지니어링(over engineering)이 언더 엔지니어링(under engineering)보다 나쁠 때가 훨씬 많기 때문이다. 다른 한편으로는 어떤 아키텍처 경계도 존재하지 않는 상황에서 경계가 정말로 필요하다는 사실을 발견한 경우, 그때서야 경계를 추가하려면 비용이 많이 들고 큰 위험을 감수해야 한다.

자, 바로 이것이다. 당신은 미래를 내다봐야만 한다. 당신은 현명하게 추측해야만 한다. 당신은 비용을 산정하고, 어디에 아키텍처 경계를 둬야 할지, 그리고 완벽하게 구현할 경계는 무엇인지와 부분적으로 구현할 경계와 무시할 경계는 무엇인지를 결정해야만 한다.

하지만 이는 일회성 결정은 아니다. 프로젝트 초반에는 구현할 경계가 무엇인지와 무시할 경계가 무엇인지를 쉽게 결정할 수 없다. 대신 지켜봐야 한다. 시스템이 발전함에 따라 주의를 기울여야 한다. 경계가 필요할 수도 있는 부분에 주목하고, 경계가 존재하지 않아 생기는 마찰의 어렴풋한 첫 조짐을 신중하게 관찰해야 한다.

첫 조짐이 보이는 시점이 되면, 해당 경계를 구현하는 비용과 무시할 때 감수할 비용을 가늠해 본다. 그리고 결정된 사항을 자주 검토한다. 우리의 목표는 경계의 구현 비용이 그걸 무시해서 생기는 비용보다 적어지는 바로 그 변곡점에서 경계를 구현하는 것이다.

목표를 달성하려면 빈틈없이 지켜봐야 한다.
